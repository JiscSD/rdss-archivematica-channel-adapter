// +build ignore

package main

import (
	"bytes"
	"encoding/json"
	"go/format"
	"io/ioutil"
	"log"
	"text/template"
)

var generatedTmpl = template.Must(template.New("generated").Parse(`
// generated by generator.go; DO NOT EDIT

package message

import (
    "encoding/json"
    "fmt"
)

{{range $typename, $values := .}}

type {{$typename}} int

const (
	{{range $index, $value := $values}}
		{{- if eq $index 0 -}}
			{{$typename}}_{{.}} {{$typename}} = iota
		{{else -}}
			{{$typename}}_{{.}}
		{{end -}}
	{{end}}
)

func (t {{$typename}}) String() string {
	switch t {
	{{range $values}}case {{$typename}}_{{.}}:
		return "{{.}}"
	{{end}}
	default:
		return ""
	}
}

var (
    _{{$typename}}NameToValue = map[string]{{$typename}} {
        {{range $values}}"{{.}}": {{$typename}}_{{.}},
        {{end}}
	}

    _{{$typename}}ValueToName = map[{{$typename}}]string {
        {{range $values}}{{$typename}}_{{.}}: "{{.}}",
        {{end}}
    }
)

func init() {
    var v {{$typename}}
    if _, ok := interface{}(v).(fmt.Stringer); ok {
        _{{$typename}}NameToValue = map[string]{{$typename}} {
            {{range $values}}interface{}({{$typename}}_{{.}}).(fmt.Stringer).String(): {{$typename}}_{{.}},
            {{end}}
        }
    }
}

// MarshalJSON is generated so {{$typename}} satisfies json.Marshaler.
func (r {{$typename}}) MarshalJSON() ([]byte, error) {
    if s, ok := interface{}(r).(fmt.Stringer); ok {
        return json.Marshal(s.String())
    }
    s, ok := _{{$typename}}ValueToName[r]
    if !ok {
        return nil, fmt.Errorf("invalid {{$typename}}: %d", r)
    }
    return json.Marshal(s)
}

// UnmarshalJSON is generated so {{$typename}} satisfies json.Unmarshaler.
func (r *{{$typename}}) UnmarshalJSON(data []byte) error {
    var s string
    if err := json.Unmarshal(data, &s); err != nil {
        return fmt.Errorf("{{$typename}} should be a string, got %s", data)
    }
    v, ok := _{{$typename}}NameToValue[s]
    if !ok {
        return fmt.Errorf("invalid {{$typename}} %q", s)
    }
    *r = v
    return nil
}

{{end}}
`))

func main() {
	analysis := make(map[string][]string)
	for name, items := range loadEnums() {
		name = name + "Enum"
		analysis[name] = items
	}

	var buf bytes.Buffer
	if err := generatedTmpl.Execute(&buf, analysis); err != nil {
		log.Fatalf("generating code: %v", err)
	}

	src, err := format.Source(buf.Bytes())
	if err != nil {
		// Should never happen, but can arise when developing this code.
		// The user can compile the output to see the error.
		log.Printf("warning: internal error: invalid Go generated: %s", err)
		log.Printf("warning: compile the package to analyze the error")
		src = buf.Bytes()
	}

	const path = "./shared_enumeration_gen.go"
	if err := ioutil.WriteFile(path, src, 0644); err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

type EnumerationDocument struct {
	Definitions map[string]Enumeration `json:"definitions"`
}

type Enumeration struct {
	Enum []string `json:"enum"`
}

const enumFile = "../../message-api-spec/schemas/enumeration.json"

func loadEnums() map[string][]string {
	bytes, err := ioutil.ReadFile(enumFile)
	if err != nil {
		log.Fatalf("loading enumeration.json: %v", err)
	}

	var doc EnumerationDocument
	err = json.Unmarshal(bytes, &doc)
	if err != nil {
		log.Fatalf("decoding enumeration.json: %v", err)
	}

	enums := make(map[string][]string)
	for name, value := range doc.Definitions {
		enums[name] = value.Enum
	}

	return enums
}
